# 递归

递归（Recursion）是一种应用十分广泛的算法（或编程技巧），也是其他一些复杂数据结构和算法的基石，如 `DFS 深度优先搜索`、`前中后序二叉树遍历` 等。

## 一、一个标准的递归求解问题（找自己的座位在第几排）

问题如下：

```
1. 让一群人按前后顺序坐着，并且除了第一个人外，其他人都蒙上眼睛。
2. 每个人只能询问自己前面最近的人，回答后面最近的人。
3. 那么在位置 n 的人如何知道自己的位置究竟在第几排呢？
```

根据问题的描述，我们发现：

```
1. 第一个人知道他的座位在第 1 排。
2. 位置 n 的人，只能问前一个人，即位置 n-1 的人。
3. 只要知道前一个人的位置，那么加上 1 就可知晓自己的位置。
```

所以我们可以列出基本的递推公式：

```
f(1)=1
f(n)=f(n-1)+1
```

这样就可以写出递归代码，Java 代码示例如下：

```java
int f(int n){
    if(n == 1) return 1;
    return f(n-1) + 1;
}
```

这个问题之所以被称为标准的递归求解问题，是因为这个问题中：

* 人依次向前询问，这就是 `递`

* 依次向后回答，这就是 `归`

* 这也就是 `递归` 这个叫法的由来。

另外，从代码示例可以看出，函数内部调用了函数自身，所以通常只要一个函数内部调用了函数自身，我们就称这个函数为 `递归函数` 。

## 二、递归的条件和分析方法

从标准的递归求解问题看出，要使用递归来解决问题，那么需要满足以下条件：

```
1. 一个问题的解可以分解为一个或多个子问题的解，只是数据规模不一样。
2. 问题存在最小的子问题，且最小的子问题是有解的，即存在递归的终止条件。
```

如台阶走法问题：

```
假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？
```

根据问题描述，我们发现：

```
1. 当只有 1 个台阶时，只有 1 种走法。
2. 当有 2 个台阶时，有 2 种走法。
3. 当有 n 个台阶时，可以先跨 1 个台阶，或者 2 个台阶
4. 当先跨 1 个台阶时，只需要知道剩下 n-1 个台阶的走法
5. 当先跨 2 个台阶时，只需要知道剩下 n-2 个台阶的走法
6. 所以有 n 个台阶时，走法为 n-1 个台阶的走法，加上 n-2 个台阶的走法。
```

所以我们可以列出递推公式：

```
f(1)=1
f(2)=2
f(n)=f(n-1)+f(n-2)
```

递归代码的 Java 示例如下：

```java
int f(int n){
    if(n == 1) return 1;
    if(n == 2) return 2;
    return f(n-1) + f(n-2);
}
```

从前面的两个问题的例子，我们可以总结出递归问题的分析方法：

```
1. 先找到最小情况的解，最小情况可能有多个。
2. 将问题分解为一个或多个子问题，并假定子问题已经有解了。
3. 找到问题与子问题的关联关系，写成递推公式，最后转换为代码。
```

## 三、写递归代码需要注意的问题

在编写递归代码时，需要注意两个问题：`堆栈溢出`、`重复计算`。

### 3.1 堆栈溢出

递归代码的一个明显特征，是递归函数内部会调用函数自身。

由于编译器用栈来管理函数之间的调用关系，所以递归函数执行时，会不停地将递归函数入栈。

而栈的空间是有限的，所以可能会堆栈溢出。

两种解决方法：

（1）设置一个变量，限制递归调用的次数。

（2）改写为非递归方式，比如台阶走法问题：

```java
int f(int n){
    if(n == 1) return 1;
    if(n == 2) return 2;
    return f(n-1) + f(n-2);
}
```

可改为 `for 循环`：

```java
int f(int n){
    int count = 0;
    int num1 = 0;
    int num2 = 1;
    for(int i=1; i<=n; i++){
        count = num1+num2;
        num1 = num2;
        num2 = count;
    }
    return count;
}
```

### 3.2 重复计算

在台阶走法问题中，我们可以发现以下的情况：

```
f(5)=f(4)+f(3)
f(4)=f(3)+f(2)
```

这里可以看出 `f(3)` 会被重复计算，而且当 n 比较大时，重复计算的情况会越来越多。

解决方法：用一个数据结构（如散列表）存储已经计算的值，如果计算过就直接取值。