# 二分查找

二分查找（Binary Search）算法（又称折半查找算法）是一种针对有序数据集合的查找算法。

它通过将待查询区间不断减半，从而快速找到对应的元素，效率很高，时间复杂度为 `O(logn)`。

## 一、二分查找的局限

二分查找虽然效率很高，时间复杂度为 `O(logn)`，但使用上有一定的局限：

（1）查找的数据是有序的。

（2）数据存储于数组中，这样才能随机访问。

（3）数据量太小或太大都不适用

```
1. 数据量太小时，直接遍历查找就可以，无需用二分查找。
2. 数据量太大时，由于二分查找，依赖数据有序，且存储于数组中，所以很多时候没有这么多连续的内存空间，存不下。
```

## 二、二分查找的实现

二分查找，对于有序数据存储于数组中，写法上比较简单，这里分为 `递归实现` 和 `非递归实现`。

### 2.1 递归实现二分查找

递归分析如下：

```
1. 对区间（start 为开始下标，end 为结束下标）进行二分查找目标元素（值为 value）所在位置的下标。
2. 判断值是否在区间中，若不在，则结束。
3. 取区间的中间元素，进行比较，目标元素更大，则在大于区间再二分查找，否则在小于区间再二分查找，相等则找到，结束。
```

Java 代码示例如下：

```java
int binarySearch(int[] a, int n, int value){
    if(value<a[0]||value>a[n-1]) return -1; // 元素不在数组中，这里直接判断，更为高效
    return search(a,0,n-1,value);
}
int search(int[] a, int start, int end, int value){
    if(start>end) return -1;
    int middle = start+(end-start)/2; // 避免 start + end 数值溢出
    if(value == a[middle]){
        return middle;
    }else if(value < a[middle]){
        return search(a,start,middle-1,value);
    }else{
        return search(a,middle+1,end,value);
    }
}
```

### 2.2 非递归实现二分查找

非递归实现，主要是用 while 循环进行，Java 代码示例如下：

```java
int binarySearch(int[] a, int n, int value){
    if(value<a[0] || value>a[n-1]) return -1; // 元素不在数组中
    int start = 0; // 区间开始下标
    int end = n-1; // 区间结束下标
    while(start <= end){
        int middle = start + (end - start)/2; // 取区间中间下标
        if(value == a[middle]){
            return middle;
        }else if(value < a[middle]){
            end = middle - 1;
        }else{
            start = middle + 1;
        }
    }
    return -1;
}
```