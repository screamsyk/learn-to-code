# 排序

排序（Sort）是我们平常经常会用到的一种算法，大部分编程语言也内置了排序函数。

排序算法有很多种，很多我们连名字都可能没有听过，比如 `猴子排序`、`睡眠排序`、`面条排序` 等。

我们主要学习最经典、最常用的排序算法，按时间复杂度分为：

* O(n^2)：`冒泡排序`、`插入排序`、`选择排序`

* O(nlogn)：`归并排序`、`快速排序`

* O(n)：`计数排序`、`基数排序`、`桶排序`

## 一、时间复杂度相同时，如何选择排序算法？

我们可以发现 `冒泡排序`、`插入排序` 和 `选择排序` 的时间复杂度都为 `O(n^2)`，但平常更倾向于使用 `插入排序`。

原因在于这个是平均情况时间复杂度，而评价一个排序算法时，要综合考虑以下几个方面：

（1）执行效率

```
1. 最好、最坏、平均情况时间复杂度。
2. 时间复杂度的系数、常数和低阶（通常数据量小，需要考虑这个）。
3. 数据比较的次数和数据交换（移动）的次数。
```

（2）内存消耗

```
1. 内存消耗，就是空间复杂度。
2. 空间复杂度为 O(1) 的称为原地排序。
```

（3）稳定性

```
1. 排序结束，相等元素的前后顺序并未发生改变，即为稳定。
2. 稳定的好处在于，如按商品价格进行商品排序，同样价格的商品，排序结束后，仍能保持排序之前的前后顺序。
```

## 二、有序度、满有序度和逆序度

在学习具体的每个排序算法前，我们还得了解下 `有序度`、`满有序度` 和 `逆序度` 的概念。

### 2.1 有序度

有序度是指数组中，具有有序关系的元素对的个数。如下图：

![有序度](img/order-degree.jpg)

### 2.2 满有序度

当数组中的元素完全有序时，此时的有序度，就是满有序度。

如果数组大小为 `n`，那么满有序度就是从 `n` 个元素中选出 `2` 个元素组成无序对。

所以由数学上的概念算法可得，满有序度为：`C(n)(2) = n*(n-1)/2`

### 2.3 逆序度

逆序度指的是没有有序关系的元素对的个数。

逆序度可以由满有序度减去有序度得到，即：`逆序度 = 满有序度 - 有序度` 。

## 三、时间复杂度为 `O(n^2)` 的经典排序算法

时间复杂度为 `O(n^2)` 的经典排序算法主要是 `冒泡排序`、`插入排序`、`选择排序`。

除此之外，还有个 `希尔排序`，它是 `插入排序` 的优化版，时间复杂为 `O(n(logn)^2)`，但不稳定。

我们接下来按照用数组 `a` 存储 `n` 个元素，数组从左到右横向放置（逻辑视觉上，下标 `0` 在最左侧），将元素从小到大进行排序。

小技巧：

```
1. 数组长度为 1 时，就不需要排了。
2. 当进行从大到小排序时，只是将条件做很小的改变（比如选大的，改为选小的）
3. 写排序算法需要双重循环时，先确定好内层循环，才好推出外层循环。
```

### 3.1 冒泡排序（Bubble Sort）

冒泡排序的主要思路如下：

```
1. 逻辑上将数组分为未排序区间（左）和已排序区间（右）。
2. 遍历未排序区间，相邻元素进行比较。
3. 若左侧元素大于右侧元素，则进行交换，否则不交换。
4. 比较完后，未排序区间的最后一个元素，就进入已排序区间。
5. 循环进行未排序区间的遍历，直到不存在交换操作。
```

Java 代码示例如下：

```java
void bubbleSort(int[] a, int n){
    if(n <= 1) return;
    for(int rightSize = 0; rightSize <= n; rightSize++){ // rightSize 为已排序区间的大小
        boolean noExchange = true; 
        int leftSize = n - rightSize; // leftSize 为未排序区间的大小
        for(int i = 0; i <= leftSize-2; i++){ // 遍历未排序区间
            if(a[i] > a[i+1]){ // 左侧元素大于右侧元素，则交换
                noExchange = false;
                int temp = a[i+1];
                a[i+1] = a[i];
                a[i] = temp;
            }
        }
        if(noExchange) break; // 不存在交换操作，证明已经完全有序了，于是结束之后的循环 
    }
}
```

可以看出冒泡排序的性能如下：

```
1. 当数组完全有序时，仅需进行一次未排序区间的遍历，所以最好情况时间复杂度为 O(n)。
2. 当数组完全无序时，最坏情况时间复杂度为 O(n^2)。
3. 交换时，只用到了常量级的空间，所以空间复杂度为 O(1)，也就是原地排序。
4. 元素相等时，不会交换顺序，所以是稳定的。
```

### 3.2 插入排序（Insertion Sort）

插入排序的主要思路如下：

```
1. 逻辑上将数组分为已排序区间（左）和未排序区间（右）。
2. 将数组的第一个元素，归入已排序区间。
3. 循环取未排序区间的第一个元素，与已排序区间的所有元素进行比较排序，插入到对应的位置。
4. 向已排序区间中插入取出的值，小技巧是倒序遍历。
```

Java 代码示例如下：

```java
void insertionSort(int[] a, int n){
    if(n <= 1) return;
    for(int i = 1; i < n; i++){ // 遍历未排序区间
        int item = a[i];
        int size = i; // size 为已排序区间的大小
        for(int j = size-1; j >= 0; j--){ // 向已排序区间中插入取出的值，小技巧是倒序遍历
            if(item < a[j]){ // 取出的值，小于当前遍历的值（这里的判断条件，如果直接写在 for 循环的条件中，代码会更简洁）
                a[j+1] = a[j]; // 将当前遍历的值向后移动
            }else{
                break;
            }
        }
        a[j+1] = item;
    }
}
```

可以看出插入排序的性能如下：

```
1. 当数组完全有序时，只需要遍历未排序空间，所以最好情况时间复杂度为 O(n)。
2. 当数组完全无序时，最坏情况时间复杂度为 O(n^2)。
3. 由于移动时，只涉及常量级的空间，所以空间复杂度为 O(1)。
4. 由于元素相等时，不会进行移动，所以是稳定的。
```

### 3.3 选择排序（Selection Sort）

选择排序的主要思路如下：

```
1. 逻辑上将数组分为已排序区间（左）和未排序区间（右）。
2. 循环遍历未排序区间，取出其中的最小值，归入已排序区间。
```

Java 代码示例如下：

```java
void selectionSort(int[] a, int n){
    if(n == 1) return;
    for(int size = 0; size < n; size++){ // size 为已排序区间的大小，也相当于未排序区间的起始下标
        int min = a[size];
        int min_i = size;
        for(int i = size+1; i < n; i++){ // 找到未排序空间的最小值
            if(a[i] < min){
                min = a[i];
                min_i = i;
            }
        }
        // 将未排序区间的最小值，归入已排序区间
        int temp = a[size];
        a[size] = min;
        a[min_i] = temp;
    }
}
```

可以看出插入排序的性能如下：

```
1. 最好、最坏情况时间复杂度都为 O(n^2) 。
2. 由于只用到了变量存储最小值，以及进行交换，所以空间复杂度为 O(1)。
3. 由于存在最小值的交换，所以会导致相同的值，前后顺序发生改变，不稳定。
```

### 3.4 希尔排序（Shell Sort）

希尔排序是对插入排序的一种优化，但它是不稳定的。参考 [希尔排序](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)

由于插入排序每次只移动一位元素，效率低，所以希尔排序用较大的步长移动元素，这样较小的元素只需要较少的比较和移动，就能达到有序状态。

希尔排序减少了插入排序的平均情况时间复杂度，时间复杂度为 `O(n(logn)^2)`，但它是不稳定的，即相等元素的前后顺序可能会变。

希尔排序的主要思路如下：

```
1. 将数组元素按一定的大小（即步长，建议取半，虽然有更好的取法，但通用性较差）进行划分。
2. 逻辑上把元素依次归入一张表中，表的列数为步长。
3. 再对表的每一列，进行插入排序。
4. 不断对步长取半，直到步长为 1，最终插入排序完成。
```

Java 代码示例如下：

```java
void shellSort(int[] a, int n){
    if(n == 1) return;
    for(int step = n/2; step >= 1; step = step/2){ // 步长循环减半至 1 
        for(int i = step; i < n; i++){ // 对逻辑表的每一列进行插入排序
            int item = a[i];
            for(int j = i-step; j >= 0&& a[j]>item; j-=step){ // 遍历当前列的元素，只是注意下标距离是 step，而不是 1
                a[j+step] = a[j];
            }
            a[j+step] = item;
        }
    }
}
```

### 3.5 平均情况时间复杂度相同时，为什么优先选择插入排序？

从 `冒泡排序`、`插入排序`、`选择排序` 三者的性能来看:

```
1. 选择排序的最好、最坏时间复杂度都为 O(n^2)，且不稳定，所以最差。
2. 冒泡排序和插入排序的性能很相似，但冒泡排序是进行元素交换，需要三次赋值，比插入排序的赋值操作更多。
```

所以综上，虽然三者平均情况时间复杂度都为 `O(n^2)`，但优先选择插入排序。

