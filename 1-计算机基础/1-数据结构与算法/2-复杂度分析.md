# 复杂度分析

Pascal 语言之父 [Nicklaus Wirth](https://baike.baidu.com/item/Nicklaus%20Wirth) 提出了对计算机科学有重大影响的一句话：

> 程序 = 数据结构 + 算法

学习好数据结构和算法，就是为了用来解决程序 “快” 和 “省” 的问题。

* 快：如何让程序运行得更快
* 省：如何让程序更节省存储空间

那么如何衡量 “快” 和 “省” 呢？答案的是进行 `时间复杂度` 和 `空间复杂度` 分析。

## 一、事后统计法

当我们运行程序（或者说执行代码）时，通过一些监控、统计工具，可以得到代码的执行时间和占用的内存大小。

这种分析方法，称为 `事后统计法` ，但有以下的局限性：

（1）测试结果受测试环境影响

测试结果受硬件等测试环境因素影响大，比如用 i9 处理器要比 i3 处理器执行一段代码要快很多。

（2）测试结果受数据影响

对于排序算法来说，同一个排序算法，数据是否已排序，对执行效率的影响很大。另外数据量的大小也会有影响，比如数据量小时，插入排序比快速排序更快。

所以我们进行时间、空间复杂度分析时，不是采用事后统计法，而是采用不需要具体数据进行测试，只是粗略估计的方法。

## 二、大 O 复杂度表示法

大 O 复杂度表示法，是对代码的时间复杂度和空间复杂度进行粗略评估的方法，所以又可细分为 `大 O 时间复杂度表示法` 和 `大 O 空间复杂度表示法` 。

### 2.1 大 O 时间复杂度表示法

时间复杂度，粗略地讲是指代码执行所花费的时间。

但这里我们并不真的执行代码，所以假设每一行代码的执行时间一样，为 `unit_time` 。

示例代码（计算 `1,2,3,...,n` 的和）：

```javascript
1  function getSum(n){
2      var sum = 0;
3      for(var i=1;i++;i<=n){
4          sum += i
5      }
6      return sum;
7  }
```

那么如何计算这个函数执行的时间呢？如下：

```
1. 第 2 行需要 1 个 unit_time 的时间
2. 第 3 、 4 行重复执行了 n 次，需要 2n 个 unit_time 的时间
3. 第 6 行是返回值，不涉及读写和运算，所以不用记录时间
```

所以函数的执行时间为 `1+2n` 个 `unit_time` 。

我们用 `O(1+2n)` 表示此代码执行时间，这就是 `大 O 时间复杂度表示法` 。

> O 代表 order，表示阶数，参考 [维基百科](https://en.wikipedia.org/wiki/Big_O_notation) 

`大 O 时间复杂度` 并不是真正的代码执行时间，而是表示代码的执行时间随数据规模的增长趋势，所以也称为 `渐进时间复杂度`，简称 `时间复杂度` 。

当数据 `n` 很大时，时间复杂度 `O(1+2n)` 也会更大，而像公式中的常量 `1` 、系数 `2` 以及低阶都不会左右增长趋势，所以可以省略为 `O(n)` 。

### 2.2 大 O 空间复杂度表示法

`大 O 空间复杂度表示法` 和 `大 O 时间复杂度表示法`类似，只是关注点是存储空间。

`大 O 空间复杂度` 表示代码的存储空间随数据规模的增长趋势，所以也称为 `渐进空间复杂度`，简称 `时间复杂度` 。

示例代码（向数组 `array` 中添加 `n` 个元素）：

```javascript
1  function getArray(n){
2      var array = [];
3      var i = 1;
4      for(;i<=n;i++){
5          array.push(i);
6      }
7      return array;
8  }
```

空间复杂度计算过程如下：

```
1. 第 3 行申请了 1 个 i 的空间
2. 第 4、5 行通过循环，向数组中加入了 n 个元素，也就申请了 n 个空间
```

所以共申请了 `1+n` 个空间，用 `O(1+n)` 表示，省略影响小的后即为 `O(n)` 。

## 三、几种常见的时间复杂度

在日常开发中，我们常常关注的是代码的时间复杂度，以下是几种常见的:

* 多项式量级（效率从高到低）：`O(1)`、`O(logn)`、`O(n)`、`O(nlogn)`、`O(n²)`
* 非多项式量级（非常低效，可以不关注）：`O(2ⁿ)`、`O(n!)`

时间复杂度表示的是代码的执行时间随数据规模的变化趋势，所以影响小的如系数等可以省略，但基本的分析规则如下：

1. 影响法则：只关注循环、递归等执行次数多的代码，省略影响小的代码
2. 加法法则：存在多个并列的循环，则时间复杂度相加
3. 乘法法则：存在嵌套的循环，则时间复杂度相乘

### 3.1 O(1)

`O(1)`是常量级时间复杂度的表示形式，代表代码的执行时间不会随数据规模变化，如下：

```javascript
1  function exchange(a,b){
2      var t=a;
3      a=b;
4      b=t;
5  }
```

虽然函数有 3 行代码执行，但不存在循环、递归语句，执行时间不会随数据规模变化，所以即使有成千上万行代码，时间复杂度也为 `O(1)`。

### 3.2 O(logn)

`O(logn)` 是对数阶的时间复杂度，通常也是最难分析的，如下：

```javascript
1  function main(n){
2      var i = 1;
3      while(i<=n){
4          i = i*2;
5      }
6  }
```

可以发现，第 4 行的代码并不是简单的执行了 `n` 次，如下（假设执行次数为 `x` ）：

```
n 的值：  0  1  2  3  4  ...  n
x 的值：  0  1  2  2  3  ...  x
i 的值：  1  2  4  4  8  ...  2^x

```

从上可知，当数据规模为 `n` 时，`i` 的值为 `2^x`。

所以我们能根据 `i` 的值，得到执行次数 `x` 与数据规模 `n` 的关系：

```
1. 由于 n => 2^x，所以 x 为 log(2)n ，即以 2 为底，n 的对数 
2. x 为 log(2)n 只是对应关系，表示一种趋势，而不是数学上的相等
3. 当底 2 变为 3 时，x 为 log(3)n ，由对数的换底公式可得： log(3)n = log(3)2 * log(2)n，省略 log(2)3 后，仍可以为 log(2)n
```

综上，无论对数的底为什么值，都可转换为 log(2)n ，所以底数是没有关系的，于是忽略底数就将时间复杂度记为 `O(logn)` 了。

### 3.3 O(n)

`O(n)` 是比较常见的时间复杂度，如下：

```javascript
1  function main(n){
2      var sum = 0;
3      for(var i=1;i<=n;i++){
4          sum+=i;
5      }
6  }
```

从代码可知，根据影响法则，第 3、4 行代码是主要影响，共会执行 2n 次，省略影响小的后，时间复杂度为 `O(n)` 。

### 3.4 O(nlogn)、O(n²)、O(m+n)、O(m*n)

如 `O(nlogn)`、`O(n²)`、`O(m+n)` 等，都可以根据乘法法则和加法法则，得到相应的时间复杂度。