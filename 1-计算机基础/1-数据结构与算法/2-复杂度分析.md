# 复杂度分析

Pascal 语言之父 [Nicklaus Wirth](https://baike.baidu.com/item/Nicklaus%20Wirth) 提出了对计算机科学有重大影响的一句话：

> 程序 = 数据结构 + 算法

学习好数据结构和算法，就是为了用来解决程序 “快” 和 “省” 的问题。

* 快：如何让程序运行得更快
* 省：如何让程序更节省存储空间

那么如何衡量 “快” 和 “省” 呢？答案的是进行 `时间复杂度` 和 `空间复杂度` 分析。

## 一、事后统计法

当我们运行程序（或者说执行代码）时，通过一些监控、统计工具，可以得到代码的执行时间和占用的内存大小。

这种分析方法，称为 `事后统计法` ，但有以下的局限性：

（1）测试结果受测试环境影响

测试结果受硬件等测试环境因素影响大，比如用 i9 处理器要比 i3 处理器执行一段代码要快很多。

（2）测试结果受数据影响

对于排序算法来说，同一个排序算法，数据是否已排序，对执行效率的影响很大。另外数据量的大小也会有影响，比如数据量小时，插入排序比快速排序更快。

所以我们进行时间、空间复杂度分析时，不是采用事后统计法，而是采用不需要具体数据进行测试，只是粗略估计的方法。

## 二、大 O 复杂度表示法

大 O 复杂度表示法，是对代码的时间复杂度和空间复杂度进行粗略评估的方法，所以又可细分为 `大 O 时间复杂度表示法` 和 `大 O 空间复杂度表示法` 。

### 2.1 大 O 时间复杂度表示法

时间复杂度，粗略地讲是指代码执行所花费的时间。

但这里我们并不真的执行代码，所以假设每一行代码的执行时间一样，为 `unit_time` 。

示例代码（计算 `1,2,3,...,n` 的和）：

```javascript
1  function getSum(n){
2      var sum = 0;
3      for(var i=1;i++;i<=n){
4          sum += i
5      }
6      return sum;
7  }
```

那么如何计算这个函数执行的时间呢？如下：

```
1. 第 2 行需要 1 个 unit_time 的时间
2. 第 3 、 4 行重复执行了 n 次，需要 2n 个 unit_time 的时间
3. 第 6 行是返回值，不涉及读写和运算，所以不用记录时间
```

所以函数的执行时间为 `1+2n` 个 `unit_time` 。

我们用 `O(1+2n)` 表示此代码执行时间，这就是 `大 O 时间复杂度表示法` 。

> O 代表 order，表示阶数，参考 [维基百科](https://en.wikipedia.org/wiki/Big_O_notation) 

`大 O 时间复杂度` 并不是真正的代码执行时间，而是表示代码的执行时间随数据规模的增长趋势，所以也称为 `渐进时间复杂度`，简称 `时间复杂度` 。

当数据 `n` 很大时，时间复杂度 `O(1+2n)` 也会更大，而像公式中的常量 `1` 、系数 `2` 以及低阶都不会左右增长趋势，所以可以省略为 `O(n)` 。

### 2.2 大 O 空间复杂度表示法

`大 O 空间复杂度表示法` 和 `大 O 时间复杂度表示法`类似，只是关注点是存储空间。

`大 O 空间复杂度` 表示代码的存储空间随数据规模的增长趋势，所以也称为 `渐进空间复杂度`，简称 `时间复杂度` 。

示例代码（向数组 `array` 中添加 `n` 个元素）：

```javascript
1  function getArray(n){
2      var array = [];
3      var i = 1;
4      for(;i<=n;i++){
5          array.push(i);
6      }
7      return array;
8  }
```

空间复杂度计算过程如下：

```
1. 第 3 行申请了 1 个 i 的空间
2. 第 4、5 行通过循环，向数组中加入了 n 个元素，也就申请了 n 个空间
```

所以共申请了 `1+n` 个空间，用 `O(1+n)` 表示，省略影响小的后即为 `O(n)` 。

## 三、几种常见的时间复杂度

在日常开发中，我们常常关注的是代码的时间复杂度，以下是几种常见的:

* 多项式量级（效率从高到低）：`O(1)`、`O(logn)`、`O(n)`、`O(nlogn)`、`O(n²)`
* 非多项式量级（非常低效，可以不关注）：`O(2ⁿ)`、`O(n!)`

### 3.1 O(1)