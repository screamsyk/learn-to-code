# 树

我们之前学习的数据结构都是 `线性表数据结构`，数据之间都是前后的关系。

其中最基础的是 `数组` 和 `链表`，主要是 `内存空间` 的分布不同，一个连续，一个可以不连续。

然后通过 `操作受限` 得到数据结构 `栈`（后进先出）和 `队列`（先进先出）。

再通过对 `链表` 进行扩展得到查找效率高的 `跳表`，对 `数组` 进行扩展得到用键 `key` 快速访问的 `散列表`。

这里学习第一种 `非线性表数据结构`，也就是 `树`

## 一、树的基本概念

树（Tree）是一种非线性表数据结构，数据元素之间不只是简单的前后关系，如下：

![树](img/tree-1.jpg)

看起来很现实中的树倒立着的样子，而为了方便描述，如下图：

![树](img/tree-2.jpg)

我们把树中的每个元素称为 `节点`，相邻节点之间为 `父子关系`，具体如下：

其中 `A` 是 `B` 的 `父节点`，`B` 是 `A` 的 `子节点`，拥有相同父节点 `A` 的 `B C D` 互称为 `兄弟节点`。

没有父节点的 `E` 为 `根节点`，没有子节点的 `G H I J K L` 为 `叶子节点` 或者 `叶节点`。

每个节点也有它的一些特征（或属性），如下：

![树](img/tree-3.jpg)

1. `度`：一个节点拥有的子节点的个数，称为节点的 `度`。比如 `A` 的 `度` 为 `3`。
2. `高度（Height）`：节点到叶子节点的最长路径的边数（理解：从下往上开始计数，起点为 0）
3. `深度（Depth）`：根节点到此节点的边数（理解：从上往下计数，起点为 0）
4. `层（Level）`：节点的深度加一（理解：从上往下计数，起点为 1）

这样看，节点的一些特征，就和日常生活的叫法很类似，通过类比也能很好地理解。

## 二、二叉树

树的每个节点可以拥有很多的子节点，结构繁多，而平常用得最多的树，是 `二叉树`。

二叉树（Binary Tree）中，每个节点最多拥有 `2` 个子节点，称为 `左子节点` 和 `右子节点`。

另外，由 `左子节点` 及其下的所有节点，称为 `左子树`，相对地，还有 `右子树`。

### 2.1 特殊的二叉树

二叉树中，根据节点的分布情况，有一些特殊的叫法，如：

1. `满二叉树`：当二叉树中，每一层的节点数都达到最大值时，称此二叉树为 `满二叉树`。
2. `完全二叉树`：当二叉树中，除最底层外，每一层的节点数都达到最大值，且最底层中节点都靠左时，称此二叉树为 `完全二叉树`。

可以看出，`满二叉树` 也是一种 `完全二叉树`。

满二叉树比较好理解，而完全二叉树则需要根据如何表示（或者说存储）二叉树来理解。

### 2.2 如何表示（或存储）二叉树？

存储二叉树有两种方式：`链式存储法` 和 基于数组的 `顺序存储法`。

（1）链式存储法

链式存储法类似链表，链上每个结点存储树的节点，以及指向节点的左子节点和右子节点的指针，如图：

![链式存储法](img/tree-4.jpg)

（2）顺序存储法

顺序存储法是基于数组的，对树的节点按层进行遍历，将节点作为元素放入数组中，如图：

![顺序存储法](img/tree-5.jpg)

我们可以看出，当存储相同的二叉树时，由于 `链式存储法` 需要存储两个指针，所以更耗内存。

而 `顺序存储法`，当二叉树节点分布比较乱时，数组中有很多的空间浪费，如下：

![非完全二叉树的顺序存储](img/tree-6.jpg)

所以，当二叉树为 `完全二叉树` 时，采用基于数组的 `顺序存储法`，更节省内存空间，利用率也更高，这也是为什么要区分出 `完全二叉树` 的原因。

### 2.3 二叉树的遍历

当采用基于数组的 `顺序存储法` 存储二叉树时，是 `按层遍历` 二叉树得到元素的。

`按层遍历` 也就是 `广度优先遍历` ，需要借助 [队列](06-队列.md) 进行实现。

主要思路如下：

```
1. 利用队列先进先出的特性，先将树的根节点入队。
2. 将根节点出队，就可以得到根节点的数据，同时将根节点的左右子节点入队。
3. 这样对每个节点进行和根节点相似的操作，将当前节点出队，并将其子节点入队，这样就可以按层遍历出所有的节点。
```

Java 代码示例如下：

```java
void indexTraversal(Queue q, Node tree){ // 按层遍历
    if(tree == null) return;
    System.out.print(tree.data);
    q.enqueue(tree);
    Node p = q.dequeue();
    while(p){
        System.out.print(p.data);
        if(p.left) q.enqueue(p.left);
        if(p.right) q.enqueue(p.right);
        p =  q.dequeue();
    }
}
```

除此之外，还有三种常见的遍历方式，按照节点与其左子树和右子树的顺序关系，可分为：

`前序遍历`、`中序遍历`、`后序遍历`

（1）前序遍历

对于树的任意节点，先打印此节点，再打印它的左子树，最后打印它的右子树。（节点在最 `前`）

```java
void preOrder(Node p){ // 前序遍历
    if(p == null) return;
    System.out.print(p.data);
    preOrder(p.left);
    preOrder(p.right);
}
```

（2）中序遍历

对于树的任意节点，先打印它的左子树，再打印此节点，最后打印它的右子树。（节点在 `中`）

```java
void midOrder(Node p){ // 中序遍历
    if(p == null) return;
    preOrder(p.left);
    System.out.print(p.data);
    preOrder(p.right);
}
```

（3）后序遍历

对于树的任意节点，先打印它的左子树，再打印它的右子树，最后打印此节点。（节点在最 `后`）

```java
void postOrder(Node p){ // 后序遍历
    if(p == null) return;
    preOrder(p.left);
    preOrder(p.right);
    System.out.print(p.data);
}
```

这三种遍历方式，可以说是 `深度优先遍历`，都是 `递归` 的过程，实现起来比较简单。

## 三、二叉查找树

二叉查找树（Binary Search Tree），又称 `二叉搜索树`，是二叉树中的一种常用类型。

二叉查找树，是专门用于实现快速查找的，对于其中任意节点来说，其左子树的节点值都更小，右子树的节点值都更大。

### 3.1 二叉查找树的查找操作

当中序遍历二叉查找树时，得出的序列正好是从小到大排好序的，所以和 `二分查找` 很类似，理想情况下时间复杂度可为 `O(logn)`。

Java 代码示例如下：

```java
public class BinarySearchTree { // 二叉查找树
    private Node tree;

    public static class Node { // 树节点
        private int data;
        private Node left;
        private Node right;

        public Node(int data) {
            this.data = data;
        }
    }

    public Node find(int data) { // 查找操作
        Node p = tree;
        while (p != null) {
        if (data < p.data) p = p.left;
        else if (data > p.data) p = p.right;
        else return p;
        }
        return null;
    }
}
```

### 3.2 二叉查找树的插入操作

在向二叉查找树插入元素时，跟查找操作类似，只是当子树为空时，进行插入。

Java 代码示例如下：

```java
public insert(int data){ // 插入操作
    if(tree == null){
        tree = Node(data);
        return;
    }
    Node p = tree;
    while(p != null){
        if(data < p.data){
            if(p.left == null){
                p.left = Node(data);
                return;
            }
            p = p.left;
        }else{
            if(p.right == null){
                p.right = Node(data);
                return;
            }
            p = p.right;
        }
    }
}
```

### 3.3 二叉查找树的删除操作

二叉查找树的查找和插入操作比较简单，而删除操作，由于需要保持二叉查找树的特性（即中序遍历出来是有序的），所以要做一些条件判断。

主要思路如下：

```
1. 假设要删除的节点是 A 。
2. 当 A 没有子节点时，将 A 的父节点指向 A 的指针变为指向 null 即可，这样就相当于删除 A 了。
3. 当 A 只有一个子节点时，将 A 的父节点指向 A 的指针变为指向 A 的子节点即可。
4. 当 A 有两个子节点时，则需要在 A 的左子树中找到值最大的节点，或者 A 的右子树中找到值最小的节点。
5. 找到对应的节点后，将 A 的值变为节点的值。
6. 由于这个节点是最小或最大值，那么它的子节点只可能为 0 个或 1 个，所以用 2、3 的情况删除那个节点即可。
```

Java 代码示例如下：

```java
public delete(int data){
    Node p = tree; // 要删除的节点，初始为树的根节点
    Node parent = null; // 要删除的节点的父节点

    // 找到要删除的节点，及其父节点
    while(p != null && p.data != data){ 
        parent = p;
        p = data < p.data?p.left:p.right;
    }
    if(p == null) return;

    // 当要删除的节点，有两个子节点时，找到其左子树中最大节点，或者右子树中最小的节点
    if(p.left != null && p.right != null){
        Node minP = p.left;
        Node minParent = p;
        while(minP.right != null){ // 找到其左子树中最大的节点
            minParent = minP;
            minP = minP.right;
        }
        p.data = minP.data; // 数据替换

        // 将 p 指定为找到的节点，方便之后统一删除只有一个或没有子节点的节点
        p = minP;
        parent = minParent;
    }

    // 删除只有一个或没有子节点的节点
    Node child = null;
    if(p.left != null){
        child = p.left;
    }else if(p.right != null){
        child = p.right;
    }
    if(parent == null){ // 要删除的是根节点
        tree = null;
    }else{
        if(parent.left == p) parent.left = child;
        else parent.right = child;
    }

}
```

## 四、平衡二叉查找树

二叉查找树，在理想情况下，查找一个元素的时间复杂度为 `O(logn)`。

但很多时候，二叉查找树的节点左右并不平衡，导致可能退化为链表，时间复杂度也会增加为 `O(n)`。

所以需要构建一种平衡的二叉查找树，即 `平衡二叉查找树`。

### 4.1 平衡二叉树

在了解平衡二叉查找树之前，我们得先了解下 `平衡二叉树` 的定义：

```
二叉树中任意一个节点的左右子树的高度相差不能大于 1，则称此二叉树为平衡二叉树
```

可见，平衡二叉查找树，不仅要满足平衡二叉树的定义，还要满足二叉查找树的定义。

### 4.2 合格的平衡二叉查找树

[AVL 树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91) 是最早被发明出的平衡二叉查找树，完全符合平衡二叉查找树的定义。

但我们平时创建平衡二叉查找树时，不一定地要完全符合平衡二叉查找树的定义，只需要保持一定的平衡就是合格的。

因为像 `AVL 树`，在插入、删除等操作时，为了维持完全平衡，会进行很复杂的调整，比较耗时。 

平常使用的合格的平衡二叉查找树有：`伸展树（Splay Tree）`、`树堆（Treap）`、`红黑树（Red-Black Tree）` 等。

其中 `伸展树（Splay Tree）`、`树堆（Treap）` 在极端情况下，会出现时间复杂度的退化，虽然概率小，但并不稳定。

而 `红黑树（Red-Black Tree）` 是最经常用的一种，是一种 “明星树”，性能稳定，比平衡二叉查找树的叫法还出名。 

## 五、红黑树

红黑树是一种不严格的平衡二叉查找树，顾名思义，它的节点一部分标记为红色，一部分标记为黑色。

具体要求为：

```
1. 根节点为黑色。
2. 相邻节点不同为红色，即需要用黑色分隔。
3. 每个节点，可到达叶子节点的各个路径中，包含的黑色节点个数一样。
4. 叶子节点为黑色，且不包含数据。
```

关键点在第 `2` 、 `3` 点，而第 `4` 点中叶子节点为黑色的空节点，是为了简化红黑树的代码而设置的。

当去除红色节点时，如下：

![红黑树](img/red-black-tree.jpg)

可以发现，去除红色节点后，任意黑色节点的左右子树高度是一样的，也就满足了第 `3` 点。

这是快速判断是否满足第 `3` 点的好方法。

### 5.1 实现红黑树的基本思想

红黑树性能高效、稳定，但实现起来比较复杂，类似还原魔方的过程：

> 遇到什么样的节点排布，我们就对应怎么去调整。

而其中涉及两个重要的操作：`左旋` 和 `右旋`。如图：

![左旋和右旋](img/left-right-rotate.jpg)

在向红黑树中插入或删除数据时，常常会破坏红黑树的定义，需要进行调整。

进行平衡调整的过程，就有 `左旋` 、 `右旋` ，以及 `改变颜色` 等操作。

而主要要注意的就是定义的第 `3` 点，即路径上黑色节点个数一样。

### 5.2 红黑树的插入操作

## 六、递归树