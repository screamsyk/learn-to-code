# 树

我们之前学习的数据结构都是 `线性表数据结构`，数据之间都是前后的关系。

其中最基础的是 `数组` 和 `链表`，主要是 `内存空间` 的分布不同，一个连续，一个可以不连续。

然后通过 `操作受限` 得到数据结构 `栈`（后进先出）和 `队列`（先进先出）。

再通过对 `链表` 进行扩展得到查找效率高的 `跳表`，对 `数组` 进行扩展得到用键 `key` 快速访问的 `散列表`。

这里学习第一种 `非线性表数据结构`，也就是 `树`

## 一、树的基本概念

树（Tree）是一种非线性表数据结构，数据元素之间不只是简单的前后关系，如下：

![树](img/tree-1.jpg)

看起来很现实中的树倒立着的样子，而为了方便描述，如下图：

![树](img/tree-2.jpg)

我们把树中的每个元素称为 `节点`，相邻节点之间为 `父子关系`，具体如下：

其中 `A` 是 `B` 的 `父节点`，`B` 是 `A` 的 `子节点`，拥有相同父节点 `A` 的 `B C D` 互称为 `兄弟节点`。

没有父节点的 `E` 为 `根节点`，没有子节点的 `G H I J K L` 为 `叶子节点` 或者 `叶节点`。

每个节点也有它的一些特征（或属性），如下：

![树](img/tree-3.jpg)

1. `度`：一个节点拥有的子节点的个数，称为节点的 `度`。比如 `A` 的 `度` 为 `3`。
2. `高度（Height）`：节点到叶子节点的最长路径的边数（理解：从下往上开始计数，起点为 0）
3. `深度（Depth）`：根节点到此节点的边数（理解：从上往下计数，起点为 0）
4. `层（Level）`：节点的深度加一（理解：从上往下计数，起点为 1）

这样看，节点的一些特征，就和日常生活的叫法很类似，通过类比也能很好地理解。

## 二、二叉树

树的每个节点可以拥有很多的子节点，结构繁多，而平常用得最多的树，是 `二叉树`。

二叉树（Binary Tree）中，每个节点最多拥有 `2` 个子节点，称为 `左子节点` 和 `右子节点`。

另外，由 `左子节点` 及其下的所有节点，称为 `左子树`，相对地，还有 `右子树`。

### 2.1 特殊的二叉树

二叉树中，根据节点的分布情况，有一些特殊的叫法，如：

1. `满二叉树`：当二叉树中，每一层的节点数都达到最大值时，称此二叉树为 `满二叉树`。
2. `完全二叉树`：当二叉树中，除最底层外，每一层的节点数都达到最大值，且最底层中节点都靠左时，称此二叉树为 `完全二叉树`。

可以看出，`满二叉树` 也是一种 `完全二叉树`。

满二叉树比较好理解，而完全二叉树则需要根据如何表示（或者说存储）二叉树来理解。

### 2.2 如何表示（或存储）二叉树？

存储二叉树有两种方式：`链式存储法` 和 基于数组的 `顺序存储法`。

（1）链式存储法

链式存储法类似链表，链上每个结点存储树的节点，以及指向节点的左子节点和右子节点的指针，如图：

![链式存储法](img/tree-4.jpg)

（2）顺序存储法

顺序存储法是基于数组的，对树的节点按层进行遍历，将节点作为元素放入数组中，如图：

![顺序存储法](img/tree-5.jpg)

我们可以看出，当存储相同的二叉树时，由于 `链式存储法` 需要存储两个指针，所以更耗内存。

而 `顺序存储法`，当二叉树节点分布比较乱时，数组中有很多的空间浪费，如下：

![非完全二叉树的顺序存储](img/tree-6.jpg)

所以，当二叉树为 `完全二叉树` 时，采用基于数组的 `顺序存储法`，更节省内存空间，利用率也更高，这也是为什么要区分出 `完全二叉树` 的原因。

### 2.3 二叉树的遍历

当采用基于数组的 `顺序存储法` 存储二叉树时，是 `按层遍历` 二叉树得到元素的。

`按层遍历` 也就是 `广度优先遍历` ，需要借助 [队列](06-队列.md) 进行实现。

主要思路如下：

```
1. 利用队列先进先出的特性，先将树的根节点入队。
2. 将根节点出队，就可以得到根节点的数据，同时将根节点的左右子节点入队。
3. 这样对每个节点进行和根节点相似的操作，将当前节点出队，并将其子节点入队，这样就可以按层遍历出所有的节点。
```

Java 代码示例如下：

```java
void indexTraversal(Queue q, Node tree){ // 按层遍历
    if(tree == null) return;
    System.out.print(tree.data);
    q.enqueue(tree);
    Node p = q.dequeue();
    while(p){
        System.out.print(p.data);
        if(p.left) q.enqueue(p.left);
        if(p.right) q.enqueue(p.right);
        p =  q.dequeue();
    }
}
```

除此之外，还有三种常见的遍历方式，按照节点与其左子树和右子树的顺序关系，可分为：

`前序遍历`、`中序遍历`、`后序遍历`

（1）前序遍历

对于树的任意节点，先打印此节点，再打印它的左子树，最后打印它的右子树。（节点在最 `前`）

```java
void preOrder(Node p){ // 前序遍历
    if(p == null) return;
    System.out.print(p.data);
    preOrder(p.left);
    preOrder(p.right);
}
```

（2）中序遍历

对于树的任意节点，先打印它的左子树，再打印此节点，最后打印它的右子树。（节点在 `中`）

```java
void midOrder(Node p){ // 中序遍历
    if(p == null) return;
    preOrder(p.left);
    System.out.print(p.data);
    preOrder(p.right);
}
```

（3）后序遍历

对于树的任意节点，先打印它的左子树，再打印它的右子树，最后打印此节点。（节点在最 `后`）

```java
void postOrder(Node p){ // 后序遍历
    if(p == null) return;
    preOrder(p.left);
    preOrder(p.right);
    System.out.print(p.data);
}
```

这三种遍历方式，可以说是 `深度优先遍历`，都是 `递归` 的过程，实现起来比较简单。

## 三、二叉查找树

二叉查找树（Binary Search Tree），又称 `二叉搜索树`，是二叉树中的一种常用类型。

二叉查找树，是专门用于实现快速查找的，对于其中任意节点来说，其左子树的节点值都更小，右子树的节点值都更大。

### 3.1 二叉查找树的查找操作

当中序遍历二叉查找树时，得出的序列正好是从小到大排好序的，所以和 `二分查找` 很类似，理想情况下时间复杂度可为 `O(logn)`。

Java 代码示例如下：

```java
public class BinarySearchTree { // 二叉查找树
    private Node tree;

    public static class Node { // 树节点
        private int data;
        private Node left;
        private Node right;

        public Node(int data) {
            this.data = data;
        }
    }

    public Node find(int data) { // 查找操作
        Node p = tree;
        while (p != null) {
        if (data < p.data) p = p.left;
        else if (data > p.data) p = p.right;
        else return p;
        }
        return null;
    }
}
```

### 3.2 二叉查找树的插入操作

在向二叉查找树插入元素时，跟查找操作类似，只是当子树为空时，进行插入。

Java 代码示例如下：

```java
public insert(int data){ // 插入操作
    if(tree == null){
        tree = Node(data);
        return;
    }
    Node p = tree;
    while(p != null){
        if(data < p.data){
            if(p.left == null){
                p.left = Node(data);
                return;
            }
            p = p.left;
        }else{
            if(p.right == null){
                p.right = Node(data);
                return;
            }
            p = p.right;
        }
    }
}
```

### 3.3 二分查找树的删除操作

## 四、平衡二叉查找树

## 五、红黑树

## 六、递归树