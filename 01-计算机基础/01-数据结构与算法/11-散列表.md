# 散列表

参考资料：

> [浅谈 Hash](https://www.jianshu.com/p/ec7b848f83a7)

> [js 对象与哈希表](https://segmentfault.com/a/1190000007692754)

散列表（Hash Table），又称 `哈希表` 或 `hash 表`，是一种可以根据键 `key` 快速访问相应数据的数据结构。

散列表是数组的一种扩展，利用了数组的随机访问特性，本质上还是数组。

## 一、什么是 Hash ？

在具体谈 `散列表` 前，我们需要了解下什么是 `Hash`。

`Hash` 翻译为 `散列`，但一般直接音译为 `哈希`，表示的是一种处理数据的思想，即 `散列思想`。

`Hash` 主要是指：把任意长度的输入通过散列算法转换为固定长度的输出，即 `散列值`。

`Hash` 有如下特点：

```
1. 输出的长度相同
2. 相同的输入，得到的输出一样（唯一性）
3. 不同的输入，得到的输出有可能一样（散列冲突）
4. 无法逆运算
```

`Hash` 的应用场景：

```
1. 登录密码加密，如 md5 加密算法。
2. 版权（唯一性）识别，如比较文件 hash 值判断视频文件是否为正版。
3. 散列表（又称 “哈希表” 或 “Hash 表”）
```

## 二、Hash 在散列表中的应用

如下场景：

```
1. 有 100 个选手参加运动会，选手的编号依次为 00 ~ 99（编号可能更复杂，比如包含班级和年龄等）。
2. 为了方便记录选手的信息，将选手编号和选手的信息放到数组中，选手编号与数组下标相对应，成映射关系。
3. 当需要读取或记录选手信息时，只需要选手的编号，就可以通过映射关系找到数组下标。
4. 利用数组的随机访问特性，就能快速找到选手的信息。
```

可以发现，这样查询选手信息的时间复杂度为 `O(1)`，效率特别高，是 `散列表` 在实际中的一种应用。

将选手编号（`键 key`）通过一定操作（`散列函数`）映射为数组下标（`散列值`）的操作，也就是 `Hash`。

存储选手编号（`键 key`）和选手信息（`值 value`）这样的 `键值对 key-value` 的数组，也就是 `散列表`。

## 三、散列表的常见应用：对象

从上面的场景，我们可以发现，散列表这种数据结构，和对象很相似，都是键值对的形式。

散列表的一种常见应用，就是表示对象。

> 面向对象编程中对象的定义和 javascript（简写为 js）语言中的对象，都是通过散列表来表示和存储的。

比如 js 中的对象：

```javascript
1  var obj = {
2      name : '小明',
3      age : 18,
4      No : 'ABC100',
5      city : '北京',
6      company : '百度',
7      weight : 65,
8      height : 175,
9      phone : '138*****887'
10 }
```

在计算机中通过散列表这种数据结构进行存储，需要将键转换为下标，即对键进行 `hash`，如下：

|键      |散列函数（先取 ASCII 值相加，再取最后一位）|散列值（下标）|
|-       |-                                         |-             |
|name    |69%10 = 9                                 |9             |
|age     |7%10 = 7                                  |7             |
|No      |198%10 = 8                                |8             |
|city    |83%10 = 3                                 |3             |
|company |56%10 = 6                                 |6             |
|weight  |3212%10 = 2                               |2             |
|height  |10010%10 = 0                              |0             |
|phone   |29%10 = 9                                 |9             |

这样，在散列表对应下标的空间存储了数据后，根据键就能找到下标，并快速取出数据。

但从上面的散列函数得到的散列值来看，不同的输入 `name` 和 `phone` ，得到了相同的输出 `9`，这就是 `散列冲突`。

## 四、散列冲突

在实际应用中，由于数组空间有限，所以 `散列冲突` 是不可避免的。

为了解决散列冲突，主要有以下方法：

`开放寻址法`（包括 `线性探测`、`二次探测`、`双重散列`）和 `链表法`

### 4.1 开放寻址法

开放寻址法的主要思想是：

```
如果出现了散列冲突，则在数组中重新探测一个空闲位置，将其插入。
```

探测方法如下：

（1）线性探测

```
1. 插入：出现散列冲突后，从当前位置循环遍历数组，找到空闲位置后，插入数据。
2. 查找：当数组中元素删除时，只做标记，根据下标没找到元素时，循环遍历数组，找到空闲位置才代表不存在元素。
3. 缺点：随着插入的元素越来越多，散列冲突越容易发生。
```

（2）二次探测

```
1. 二次探测，跟线性探测很像。
2. 线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……
3. 二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……
```

（3）双重散列

```
1. 双重散列，指的是不止一个散列函数，而是一组散列函数。
2. 如果第一个散列函数出现了散列冲突，就依次用下一个散列函数，直到不冲突。
```

开放寻址法中，无论采用哪种探测方法，随着散列表中元素越来越多，散列冲突的概率就越来越大。

我们用 `装载因子` 来表示散列表的性能：

```
散列表的装载因子=填入表中的元素个数/散列表的长度
```

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。