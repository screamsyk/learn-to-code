# 数组

数组（Array）是一种线性表数据结构。

它用一组连续的内存空间，来存储相同类型的数据。

> 可以看出如 javascript 等动态类型语言中的数组，并不是真正的数组。参考 [深究 JavaScript 数组](https://juejin.im/entry/59ae664d518825244d207196)

## 一、数组中元素的访问、插入和删除

数组采用的是连续的内存空间，并存储的是相同类型的数据，所有有以下优缺点：

* 优点：可以随机访问数组中的元素（随机访问，即可以根据下标从数组中任意元素地址开始访问，而不是必须从开始地址进行）
* 缺点：在插入、删除数组中的元素时，为保证内存空间的连续性，需要大量移动数组中的元素

所以数组的性能：访问和修改 > 插入和删除 。

### 1.1 访问

创建数组时，计算机会分配连续的内存空间，而内存空间都含有一个编号（即内存地址），假设首地址为 `base_address`。

由于数据类型相同，所以每个元素所占的内存空间是一样多的，假设为占 `type_size` 个字节，参考 [内存地址与内存空间](https://blog.csdn.net/weixin_31449201/article/details/80298099)。

在访问数组元素时，只要给出下标 `i`，计算机就可以通过如下公式，计算出元素的内存地址 `address`：

```
寻址公式：address = base_address + i * type_size
```

得到地址后，就可以得到对应的数据了，时间复杂度为 `O(1)` 。

从公式可知，下标 `i` 准确来说为偏移量，所以多数语言（如 `C`、`Java`） 数组下标从 `0` 开始，可以减少一次减一操作。

> 1. 数组下标从 `0` 开始也有历史原因，最开始是 C 语言采用的下标从 0 开始，后续语言也就跟着一起了，方便学习。  
> 2. 数组下标在其他语言中也有从 `1` 开始的，如 `Matlab`、`lua`。而且 `Python` 还支持负数的下标。 

### 1.2 插入

假设数组的长度为 `n`，需要在下标 `k` 的位置插入一个元素，则下标为 `k` ~ `n-1` 位置的元素需要依次向后移动一位。

根据平均情况时间复杂度，可得时间复杂度为：`(0+1+2+...+n)/n` => `O(n)`。

小技巧：

> 1. 如果数组中的元素需要保持插入前后的顺序，则需要依次移动元素。
> 2. 如果数组中的元素不需要保持顺序，则插入时，可以进行替换操作，把被替换元素放到数组末端。

### 1.3 删除

删除操作与插入操作类似，当删除下标为 `k` 的元素时，需要将下标为 `k` ~ `n-1` 位置的元素需要依次向前移动一位。

可知平均情况时间复杂度也为 `O(n)` 。

小技巧：

> 1. 在删除多个元素时，可以先标记为删除状态，等数组空间不够时，再一次删除，避免移动多次元素。

## 二、数组下标越界问题

在 C 语言中，数组的大小是初始时确定好了的，如下代码：

```C
1  int main(){
2      int i = 0;
3      int arr[3] = {0};
4      for(; i<=3; i++){
5          arr[i] = 0;
6          printf("hello world\n");
7      }
8  }
```

用 `gcc` 编译器编译运行后，发现会不停地输出 `hello world`，原因如下：

```
1. for 循环中结束条件写成了 i<=3 ，导致会访问到 a[3]，即数组下标越界了。
2. C 语言中，数组下标越界时，只要能找到对应的内存地址，就不会报错。
3. 根据数组元素的寻址公式，仍可以找到 a[3] 对应的内存地址。
4. 从代码中可以看到，内存中存储了变量 i 和数组 a ，而 a[3] 对应的内存地址刚好就是 i 所在的内存地址。
5. 所以每次设置 a[3]=0 时，即设置了 i=0 ，导致无限循环。
```

为什么 `a[3]` 的内存地址，正好是 `i` 所在的内存地址呢？

这要涉及到 [概念](01-概念.md) 中内存的物理结构和内存对齐、 [栈](05-栈.md)，以及 `gcc` 编译器，具体分析如下：

```
1. 一个整数占两个字节，所以数组 a 的 3 个元素共占了 6 个字节，变量 i 占了 2 个字节。
2. C 语言用栈来存储运行时数据，栈是从高地址到低地址增长的，所以先入栈的数据在高地址。
3. 默认情况下，gcc 编译器会开启堆栈保护，不管 i 声明在前还是在后，都后于数组入栈。关闭后，先声明的先入栈。
4. 综上，当关闭 gcc 编译器的堆栈保护时，i 先进入栈的高地址，依次是 a[2]、a[1]、a[0]，所以 a[3] 的地址刚好是 i 的地址。
```

所以在 C 语言中，很可能出现逻辑错误，导致数组下标越界，而又没有报错，从而很难发现和解决。

当然，像 Java 语言，自身会做数组下标越界的检查，所以越界时会直接报错。

## 三、数组容器

针对数组类型，很多语言都提供了容器类，比如 Java 语言中的 `ArrayList`。

那么容器 `ArrayList` 比数组 `Array` 如何呢？

`ArrayList` 的优势是：

* 将很多数组操作（插入、删除等）的细节封装了起来。
* 支持动态扩容。当数组大小不够时，会自动申请扩容为 1.5 倍大小。

> 由于扩容涉及内存申请和数据迁移，比较耗时，所以尽量预先设好足够的大小。

`ArrayList` 的缺点：

* `ArrayList` 不能存储基本类似的数据，比如不能存 `int`，只能存 `Integer`，有拆箱的性能消耗
* `ArrayList` 方法过多，有的用不到

综上，如果不考虑性能，那么直接用容器类 `ArrayList` 就好了。

